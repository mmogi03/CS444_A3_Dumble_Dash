<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman Game</title>
    <style>
        /* Add some basic styling to the canvas */
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <!-- Create the game canvas -->
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <script>
        // Get the canvas element and its context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set the canvas dimensions
        canvas.width = 400;
        canvas.height = 400;

        // Define the game variables
        let pacman = {
            x: 200,
            y: 200,
            speed: 5,
            direction: 'right',
            radius: 20
        };

        let ghosts = [
            { x: 100, y: 100, speed: 3, direction: 'right', radius: 20 },
            { x: 300, y: 100, speed: 3, direction: 'left', radius: 20 },
            { x: 100, y: 300, speed: 3, direction: 'down', radius: 20 },
            { x: 300, y: 300, speed: 3, direction: 'up', radius: 20 }
        ];

        let pellets = [];
        for (let i = 0; i < 10; i++) {
            pellets.push({ x: Math.random() * 400, y: Math.random() * 400, radius: 5 });
        }

        let score = 0;

        // Function to draw the game elements
        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the pacman
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(pacman.x, pacman.y, pacman.radius, 0, 2 * Math.PI);
            ctx.fill();

            // Draw the ghosts
            ctx.fillStyle = 'red';
            ghosts.forEach(ghost => {
                ctx.beginPath();
                ctx.arc(ghost.x, ghost.y, ghost.radius, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw the pellets
            ctx.fillStyle = 'white';
            pellets.forEach(pellet => {
                ctx.beginPath();
                ctx.arc(pellet.x, pellet.y, pellet.radius, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw the score
            ctx.font = '24px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Score: ${score}`, 10, 10);
        }

        // Function to update the game state
        function update() {
            // Move the pacman
            switch (pacman.direction) {
                case 'right':
                    pacman.x += pacman.speed;
                    break;
                case 'left':
                    pacman.x -= pacman.speed;
                    break;
                case 'up':
                    pacman.y -= pacman.speed;
                    break;
                case 'down':
                    pacman.y += pacman.speed;
                    break;
            }

            // Keep the pacman within the canvas boundaries
            if (pacman.x - pacman.radius < 0) {
                pacman.x = pacman.radius;
            } else if (pacman.x + pacman.radius > canvas.width) {
                pacman.x = canvas.width - pacman.radius;
            }
            if (pacman.y - pacman.radius < 0) {
                pacman.y = pacman.radius;
            } else if (pacman.y + pacman.radius > canvas.height) {
                pacman.y = canvas.height - pacman.radius;
            }

            // Move the ghosts
            ghosts.forEach(ghost => {
                switch (ghost.direction) {
                    case 'right':
                        ghost.x += ghost.speed;
                        break;
                    case 'left':
                        ghost.x -= ghost.speed;
                        break;
                    case 'up':
                        ghost.y -= ghost.speed;
                        break;
                    case 'down':
                        ghost.y += ghost.speed;
                        break;
                }

                // Keep the ghosts within the canvas boundaries
                if (ghost.x - ghost.radius < 0) {
                    ghost.x = ghost.radius;
                    ghost.direction = 'right';
                } else if (ghost.x + ghost.radius > canvas.width) {
                    ghost.x = canvas.width - ghost.radius;
                    ghost.direction = 'left';
                }
                if (ghost.y - ghost.radius < 0) {
                    ghost.y = ghost.radius;
                    ghost.direction = 'down';
                } else if (ghost.y + ghost.radius > canvas.height) {
                    ghost.y = canvas.height - ghost.radius;
                    ghost.direction = 'up';
                }
            });

            // Check for collisions with pellets
            pellets = pellets.filter(pellet => {
                const distance = Math.sqrt(Math.pow(pacman.x - pellet.x, 2) + Math.pow(pacman.y - pellet.y, 2));
                if (distance < pacman.radius + pellet.radius) {
                    score++;
                    return false;
                }
                return true;
            });

            // Check for collisions with ghosts
            ghosts.forEach(ghost => {
                const distance = Math.sqrt(Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2));
                if (distance < pacman.radius + ghost.radius) {
                    alert('Game Over!');
                    location.reload();
                }
            });
        }

        // Handle keyboard input
        document.addEventListener('keydown', event => {
            switch (event.key) {
                case 'ArrowRight':
                    pacman.direction = 'right';
                    break;
                case 'ArrowLeft':
                    pacman.direction = 'left';
                    break;
                case 'ArrowUp':
                    pacman.direction = 'up';
                    break;
                case 'ArrowDown':
                    pacman.direction = 'down';
                    break;
            }
        });

        // Main game loop
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>